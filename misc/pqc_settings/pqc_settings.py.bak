##########################################################################
##                                                                      ##
## Copyright (C) 2011-2025 Lukas Spies                                  ##
## Contact: https://photoqt.org                                         ##
##                                                                      ##
## This file is part of PhotoQt.                                        ##
##                                                                      ##
## PhotoQt is free software: you can redistribute it and/or modify      ##
## it under the terms of the GNU General Public License as published by ##
## the Free Software Foundation, either version 2 of the License, or    ##
## (at your option) any later version.                                  ##
##                                                                      ##
## PhotoQt is distributed in the hope that it will be useful,           ##
## but WITHOUT ANY WARRANTY; without even the implied warranty of       ##
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        ##
## GNU General Public License for more details.                         ##
##                                                                      ##
## You should have received a copy of the GNU General Public License    ##
## along with PhotoQt. If not, see <http://www.gnu.org/licenses/>.      ##
##                                                                      ##
##########################################################################

import os
os.makedirs('output/', exist_ok=True)

import parts.header as header
import

f = open("output/pqc_settings.h", "w")
f.write(header.get())
f.close()


##############################################################################################
##############################################################################################
##############################################################################################

cont_SOURCE = """
/**************************************************************************
 **                                                                      **
 ** Copyright (C) 2011-2025 Lukas Spies                                  **
 ** Contact: https://photoqt.org                                         **
 **                                                                      **
 ** This file is part of PhotoQt.                                        **
 **                                                                      **
 ** PhotoQt is free software: you can redistribute it and/or modify      **
 ** it under the terms of the GNU General Public License as published by **
 ** the Free Software Foundation, either version 2 of the License, or    **
 ** (at your option) any later version.                                  **
 **                                                                      **
 ** PhotoQt is distributed in the hope that it will be useful,           **
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of       **
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        **
 ** GNU General Public License for more details.                         **
 **                                                                      **
 ** You should have received a copy of the GNU General Public License    **
 ** along with PhotoQt. If not, see <http://www.gnu.org/licenses/>.      **
 **                                                                      **
 **************************************************************************/

/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
//
// WARNING
// THIS FILE IS AUTO GENERATED BY `misc/pqc_settings.py`.
// ANY CHANGES HERE WILL BE OVERWRITTEN AT SOME POINT!
//
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/

#include <QJSValue>
#include <QMessageBox>
#include <qlogging.h>   // needed in this form to compile with Qt 6.2
#include <pqc_settings.h>
#include <pqc_configfiles.h>
#include <pqc_notify.h>
#include <pqc_extensionshandler.h>

#include <scripts/pqc_scriptsother.h>

PQCSettings::PQCSettings(QObject *parent) : QQmlPropertyMap(this, parent) {

    // create and connect to default database
    if(QSqlDatabase::isDriverAvailable("QSQLITE3"))
        dbDefault = QSqlDatabase::addDatabase("QSQLITE3", "defaultsettings");
    else if(QSqlDatabase::isDriverAvailable("QSQLITE"))
        dbDefault = QSqlDatabase::addDatabase("QSQLITE", "defaultsettings");
    QFile::remove(PQCConfigFiles::get().DEFAULTSETTINGS_DB());
    QFile::copy(":/defaultsettings.db", PQCConfigFiles::get().DEFAULTSETTINGS_DB());
    dbDefault.setDatabaseName(PQCConfigFiles::get().DEFAULTSETTINGS_DB());
    if(!dbDefault.open()) {
        qCritical() << "ERROR opening default database:" << (PQCConfigFiles::get().DEFAULTSETTINGS_DB());
        QMessageBox::critical(0, QCoreApplication::translate("PQSettings", "ERROR opening database with default settings"),
                              QCoreApplication::translate("PQSettings", "I tried hard, but I just cannot open the database of default settings.") + QCoreApplication::translate("PQSettings", "Something went terribly wrong somewhere!"));
        return;
    }

    // connect to user database
    if(QSqlDatabase::isDriverAvailable("QSQLITE3"))
        db = QSqlDatabase::addDatabase("QSQLITE3", "settings");
    else if(QSqlDatabase::isDriverAvailable("QSQLITE"))
        db = QSqlDatabase::addDatabase("QSQLITE", "settings");
    db.setDatabaseName(PQCConfigFiles::get().USERSETTINGS_DB());

    dbtables = QStringList() << "general"
                             << "interface"
                             << "imageview"
                             << "thumbnails"
                             << "mainmenu"
                             << "metadata"
                             << "filetypes"
                             << "filedialog"
                             << "slideshow"
                             << "mapview"
                             << "extensions";

    readonly = false;

    QFileInfo infodb(PQCConfigFiles::get().USERSETTINGS_DB());

    if(!infodb.exists() || !db.open()) {

        qWarning() << "ERROR opening database:" << db.lastError().text();
        qWarning() << "Will load read-only database of default settings";

        readonly = true;
        db.setConnectOptions("QSQLITE_OPEN_READONLY");

        QString tmppath = QStandardPaths::writableLocation(QStandardPaths::TempLocation)+"/usersettings.db";

        if(QFile::exists(tmppath))
            QFile::remove(tmppath);

        if(!QFile::copy(":/usersettings.db", tmppath)) {
            qCritical() << "ERROR copying read-only default database!";
            //: This is the window title of an error message box
            QMessageBox::critical(0, QCoreApplication::translate("PQSettings", "ERROR getting database with default settings"),
                                     QCoreApplication::translate("PQSettings", "I tried hard, but I just cannot open even a read-only version of the settings database.") + QCoreApplication::translate("PQSettings", "Something went terribly wrong somewhere!"));
            return;
        }

        QFile f(tmppath);
        f.setPermissions(f.permissions()|QFileDevice::WriteOwner);

        db.setDatabaseName(tmppath);

        if(!db.open()) {
            qCritical() << "ERROR opening read-only default database!";
            QMessageBox::critical(0, QCoreApplication::translate("PQSettings", "ERROR opening database with default settings"),
                                     QCoreApplication::translate("PQSettings", "I tried hard, but I just cannot open the database of default settings.") + QCoreApplication::translate("PQSettings", "Something went terribly wrong somewhere!"));
            return;
        }

    } else {

        readonly = false;
        if(!infodb.permission(QFileDevice::WriteOwner))
            readonly = true;

    }

    // update with user settings
    readDB();

    dbIsTransaction = false;
    dbCommitTimer = new QTimer();
    dbCommitTimer->setSingleShot(true);
    dbCommitTimer->setInterval(400);
    connect(dbCommitTimer, &QTimer::timeout, this, [=](){
        db.commit();
        dbIsTransaction = false;
        if(db.lastError().text().trimmed().length())
            qWarning() << "ERROR committing database:" << db.lastError().text();
    });

    /******************************************************/"""

########################################
# DEFAULT VALUES
########################################

for tab in dbtables:

    c = conn.cursor()
    c.execute(f"SELECT `name`,`defaultvalue`,`datatype` FROM {tab} ORDER BY `name`")
    data = c.fetchall()

    cont_SOURCE += f"""

    // table: {tab}"""
    for row in data:

        name = row[0]
        defaultvalue = row[1]
        datatype = row[2]

        cont_SOURCE += f"""
    m_{tab}{name} = """

        if datatype == "string":
            cont_SOURCE += f"\"{defaultvalue}\""
        elif datatype == "bool":
            cont_SOURCE += ("false" if defaultvalue == "0" else "true")
        elif datatype == "int":
            cont_SOURCE += defaultvalue
        elif datatype == "double":
            cont_SOURCE += defaultvalue
        elif datatype == "list":

            cont_SOURCE += "QStringList()";
            if defaultvalue == "":
                cont_SOURCE += "QStringList()"
            else:
                parts = defaultvalue.split(":://::")
                for p in parts:
                    cont_SOURCE += f" << \"{p}\""

        elif datatype == "point":

            parts = defaultvalue.split(",")
            if len(parts) == 2:
                cont_SOURCE += f"QPoint({parts[0]}, {parts[1]})"
            else:
                cont_SOURCE += f"QPoint(0, 0)"

        elif datatype == "size":

            parts = defaultvalue.split(",")
            if len(parts) == 2:
                cont_SOURCE += f"QSize({parts[0]}, {parts[1]})"
            else:
                cont_SOURCE += f"QSize(0, 0)"

        cont_SOURCE += ";"

cont_SOURCE += """

    /******************************************************/
"""

########################################
# CHANGED SIGNAL CONNECTIONS
########################################

for tab in dbtables:

    c = conn.cursor()
    c.execute(f"SELECT `name` FROM {tab} ORDER BY `name`")
    data = c.fetchall()

    cont_SOURCE += f"""
    // table: {tab}"""
    for row in data:

        name = row[0]

        cont_SOURCE += f"""
    connect(this &PQCSettings::{tab}{name}Changed, this, [=]() {{ saveChangedValue(\"{tab}{name}\", val); }});"""
    # connect(this &PQCSettings::{tab}{name}Changed, this, &PQCSettings::saveChangedValue);



cont_SOURCE += """

    /******************************************************/

    connect(&PQCNotify::get(), &PQCNotify::settingUpdateChanged, this, &PQCSettings::updateFromCommandLine);
    connect(&PQCNotify::get(), &PQCNotify::resetSettingsToDefault, this, &PQCSettings::resetToDefault);

}"""


########################################
# GET and SET and DEF
########################################

for tab in dbtables:

    c = conn.cursor()
    c.execute(f"SELECT `name`,`defaultvalue`,`datatype` FROM {tab} ORDER BY `name`")
    data = c.fetchall()

    for row in data:

        name = row[0]
        defaultvalue = row[1]
        datatype = row[2]

        qtdatatpe = "QString"
        if datatype == "bool":
            qtdatatpe = "bool"
        elif datatype == "int":
            qtdatatpe = "int"
        elif datatype == "double":
            qtdatatpe = "double"
        elif datatype == "list":
            qtdatatpe = "QStringList"
        elif datatype == "point":
            qtdatatpe = "QPoint"
        elif datatype == "size":
            qtdatatpe = "QSize"

        cont_SOURCE += f"""
{qtdatatpe} get{tab.capitalize()}{name}() {{
    return m_{tab}{name};
}}

void set{tab.capitalize()}{name}({qtdatatpe} val) {{
    if(val != m_{tab}{name}) {{
        m_{tab}{name} = val;
        Q_EMIT {tab}{name}Changed();
    }}
}}

void setDefaultFor{tab.capitalize()}{name}() {{"""

        if datatype == "string":
            cont_SOURCE += f"""
    if(\"{defaultvalue}\" != m_{tab}{name}) {{
        m_{tab}{name} = \"{defaultvalue}\";
        Q_EMIT {tab}{name}Changed();
    }}"""

        cont_SOURCE += """
}}"""





########################################
# READ DATABASE
########################################

cont_SOURCE += """

void PQCSettings::readDB() {

    qDebug() << "";

    // then update with user values (if changed)

    for(const auto &table : std::as_const(dbtables)) {

        QSqlQuery query(db);
        query.prepare(QString("SELECT `name`,`value`,`datatype` FROM '%1'").arg(table));
        if(!query.exec())
            qCritical() << QString("SQL Query error (%1):").arg(table) << query.lastError().text();

        while(query.next()) {

            QString name = QString("%1%2").arg(table, query.value(0).toString());
            QString value = query.value(1).toString();
            QString datatype = query.value(2).toString();
        """

tablecount = 0
for tab in dbtables:

    tablecount += 1

    c = conn.cursor()
    c.execute(f"SELECT `name`,`datatype` FROM {tab} ORDER BY `name`")
    data = c.fetchall()

    prefx = ""

    if tablecount > 1:
        cont_SOURCE += """
                }"""

    cont_SOURCE += f"""
            // table: {tab}
            if(table == \"{tab}\") {{"""
    for row in data:

        name = row[0]
        datatype = row[1]

        if datatype == "string":
            cont_SOURCE += f"""
                {prefx}if(name == \"{name}\") {{
                    m_{tab}{name} = value;"""

        elif datatype == "int":
            cont_SOURCE += f"""
                {prefx}if(name == \"{name}\") {{
                    m_{tab}{name} = value.toInt();"""

        elif datatype == "double":
            cont_SOURCE += f"""
                {prefx}if(name == \"{name}\") {{
                    m_{tab}{name} = value.toDouble();"""

        elif datatype == "bool":
            cont_SOURCE += f"""
                {prefx}if(name == \"{name}\") {{
                    m_{tab}{name} = value.toBool();"""

        elif datatype == "list":
            cont_SOURCE += f"""
                {prefx}if(name == \"{name}\") {{
                    if(value.contains(":://::"))
                        m_{tab}{name} = value.split(":://::");
                    else if(value != "")
                        m_{tab}{name} = QStringList() << value;
                    else
                        m_{tab}{name} = QStringList();"""

        elif datatype == "point":
            cont_SOURCE += f"""
                {prefx}if(name == \"{name}\") {{
                    const QStringList parts = value.split(",");
                    if(parts.length() == 2)
                        m_{tab}{name} = QPoint(parts[0].toInt(), parts[1].toInt()));
                    else
                        m_{tab}{name} = QPoint(0,0);"""

        elif datatype == "size":
            cont_SOURCE += f"""
                {prefx}if(name == \"{name}\") {{
                    const QStringList parts = value.split(",");
                    if(parts.length() == 2)
                        m_{tab}{name} = QSize(parts[0].toInt(), parts[1].toInt()));
                    else
                        m_{tab}{name} = QSize(0,0);"""

        prefx = "} else "

cont_SOURCE += """
            }
        }

    }

}

bool PQCSettings::backupDatabase() {

    // make sure all changes are written to db
    if(dbIsTransaction) {
        dbCommitTimer->stop();
        db.commit();
        dbIsTransaction = false;
        if(db.lastError().text().trimmed().length())
            qWarning() << "ERROR committing database:" << db.lastError().text();
    }

    // backup file
    if(QFile::exists(QString("%1.bak").arg(PQCConfigFiles::get().USERSETTINGS_DB())))
        QFile::remove(QString("%1.bak").arg(PQCConfigFiles::get().USERSETTINGS_DB()));
    QFile file(PQCConfigFiles::get().USERSETTINGS_DB());
    return file.copy(QString("%1.bak").arg(PQCConfigFiles::get().USERSETTINGS_DB()));

}

void PQCSettings::saveChangedValue(const QString &_key, const QVariant &value) {

    qDebug() << "args: key =" << _key;
    qDebug() << "args: value =" << value;
    qDebug() << "readonly =" << readonly;

    if(readonly) return;

    dbCommitTimer->stop();

    QString key = _key;
    QString category = "";

    for(const auto &table : std::as_const(dbtables)) {
        if(key.startsWith(table)) {
            category = table;
            key = key.remove(0, table.length());
            break;
        }
    }

    if(category == "") {
        qWarning() << "ERROR: invalid category received:" << key;
        return;
    }

    QSqlQuery query(db);

    if(!dbIsTransaction) {
        db.transaction();
        dbIsTransaction = true;
    }

    // Using a placeholder also for table name causes an sqlite 'parameter count mismatch' error
    // the 'on conflict' cause performs an update if the value already exists and the insert thus failed
    query.prepare(QString("INSERT INTO '%1' (`name`,`value`,`datatype`) VALUES (:nme, :val, :dat) ON CONFLICT (`name`) DO UPDATE SET `value`=:valupdate").arg(category));

    query.bindValue(":nme", key);

    // we convert the value to a string
    QString val = "";
    if(value.typeId() == QMetaType::Bool) {
        val = QString::number(value.toInt());
        query.bindValue(":dat", "bool");
    } else if(value.typeId() == QMetaType::Int) {
        val = QString::number(value.toInt());
        query.bindValue(":dat", "int");
    } else if(value.typeId() == QMetaType::QStringList) {
        val = value.toStringList().join(":://::");
        query.bindValue(":dat", "list");
    } else if(value.typeId() == QMetaType::QPoint) {
        val = QString("%1,%2").arg(value.toPoint().x()).arg(value.toPoint().y());
        query.bindValue(":dat", "point");
    } else if(value.typeId() == QMetaType::QPointF) {
        val = QString("%1,%2").arg(value.toPointF().x()).arg(value.toPointF().y());
        query.bindValue(":dat", "point");
    } else if(value.typeId() == QMetaType::QSize) {
        val = QString("%1,%2").arg(value.toSize().width()).arg(value.toSize().height());
        query.bindValue(":dat", "size");
    } else if(value.typeId() == QMetaType::QSizeF) {
        val = QString("%1,%2").arg(value.toSizeF().width()).arg(value.toSizeF().height());
        query.bindValue(":dat", "size");
    } else if(value.canConvert<QJSValue>() && value.value<QJSValue>().isArray()) {
        QStringList ret;
        QJSValue _val = value.value<QJSValue>();
        const int length = _val.property("length").toInt();
        for(int i = 0; i < length; ++i)
            ret << _val.property(i).toString();
        val = ret.join(":://::");
        query.bindValue(":dat", "list");
    } else {
        val = value.toString();
        query.bindValue(":dat", "string");
    }

    query.bindValue(":val", val);
    query.bindValue(":valupdate", val);

    // and update database
    if(!query.exec()) {
        qWarning() << "SQL Error:" << query.lastError().text();
        qWarning() << "Category =" << category << "- value =" << value;
        qWarning() << "Executed query:" << query.lastQuery();
    }

    dbCommitTimer->start();

}

void PQCSettings::setDefault() {

    qDebug() << "readonly =" << readonly;

    if(readonly) return;

    backupDatabase();

    dbCommitTimer->stop();
    if(!dbIsTransaction) {
        db.transaction();
        dbIsTransaction = true;
    }

    for(const auto &table : std::as_const(dbtables)) {

        QSqlQuery query(db);
        if(!query.exec(QString("DELETE FROM '%1'").arg(table)))
            qWarning() << "SQL Error:" << query.lastError().text();

    }

    setupFresh();

}

QVariantList PQCSettings::getDefaultFor(QString key) {

    qDebug() << "args: key =" << key;
    qDebug() << "readonly =" << readonly;

    if(readonly) return {"", ""};

    QString tablename = "";
    QString settingname = "";

    for(auto &t : std::as_const(dbtables)) {

        if(key.startsWith(t)) {
            tablename = t;
            break;
        }

    }

    // invalid table name
    if(tablename == "") {
        qWarning() << "tablename not found";
        return {"", ""};
    }

    settingname = key.last(key.size()-tablename.size());

    QSqlQuery query(dbDefault);
    query.prepare(QString("SELECT `defaultvalue`,`datatype` FROM '%1' WHERE name='%2'").arg(tablename,settingname));
    if(!query.exec())
        qWarning() << "SQL Error:" << query.lastError().text();

    if(!query.next()) {
        qWarning() << "unable to get default value";
        return {"", ""};
    }

    return {query.value(0), query.value(1)};

}
"""

f = open("output/pqc_settings.cpp", "w")
f.write(cont_SOURCE)
f.close()
